#!/usr/bin/env python3
import os, shutil, argparse, yaml, re, base64
from datetime import datetime

# initialize CLI
progname = os.path.basename(__file__)
parser = argparse.ArgumentParser(description='Git-based package manager for Lua.')
parser.add_argument(
    '-v', '--verbosity',
    action='count',
    help='Increase output verbosity (e.g. -vv is more than -v)'
)
parser.add_argument(
    'command',
    nargs='?',
    action='store',
    default='not present',
    const='present without value',
    choices=['dump', 'require', 'remove', 'update']
)
parser.add_argument(
    'source',
    nargs='?',
    action='store',
    default='not present',
    const='present without value'
)
parser.add_argument(
    '-n', '--name',
    action='store',
    dest='name',
    help='Set name for newly required package.'
)
parser.add_argument(
    '-s', '--source_host',
    action='store',
    dest='source_host',
    help='Set source for newly required package.'
)
args = parser.parse_args()

### HELPER FUNCTIONS
# log message
VERBOSE_TYPE=[ 'LOG', 'VERBOSE', 'DEBUG' ]
def log(msg, level=1, var=None):
    if var:
        msg = msg + ' ' + str(var)
    with open(progname + '.log', 'a') as log_file:
        log_file.write(datetime.now().strftime('[%Y/%m/%d %H:%M:%S] (' + (VERBOSE_TYPE[level-1] or VERBOSE_TYPE[0]) + ') '))
        log_file.write(msg)
        log_file.write('\n')
    if args.verbosity:
        if args.verbosity >= level:
            print(msg)
    else:
        if level == 1:
            print(msg)
log('--- START', level=0)

# load configuration
def loadYaml(path):
    with open(path) as f:
        try:
            return yaml.safe_load(f)
        except yaml.YAMLError as ex:
            log('Error: ', var=ex, level=1)
    return None

# create directory in not present
def ensureDirExists(dir):
    if not os.path.exists(dir): os.makedirs(dir)

### PACKAGE MANAGER
class Manager:
    currentPath = ''
    config = {}
    autoload_template = "CnRhYmxlLmluc2VydChwYWNrYWdlLmxvYWRlcnMsIDIsIGZ1bmN0aW9uKG1vZHVsZW5hbWUpCiAgbG9jYWwgZXJybXNnLCBtb2R1bGVwYXRoID0gJycsIHN0cmluZy5nc3ViKG1vZHVsZW5hbWUsICclLicsICcvJykKICBmb3IgcGF0aCBpbiBzdHJpbmcuZ21hdGNoKHBhY2thZ2UucGF0aCwgJyhbXjtdKyknKSBkbwogICAgbG9jYWwgZmlsZW5hbWUgPSBwYXRoOmdzdWIoJyU/JywgbW9kdWxlcGF0aCk6Z3N1YignYC8nLCAnLicpCiAgICBsb2NhbCBmaWxlID0gaW8ub3BlbihmaWxlbmFtZSwgJ3JiJykKICAgIGlmIGZpbGUgdGhlbiByZXR1cm4gYXNzZXJ0KGxvYWRzdHJpbmcoYXNzZXJ0KGZpbGU6cmVhZCgnKmEnKSksIGZpbGVuYW1lKSkgZW5kCiAgICBlcnJtc2cgPSBlcnJtc2cuLiJcblx0bm8gZmlsZSAnIi4uZmlsZW5hbWUuLiInIgogIGVuZCByZXR1cm4gZXJybXNnCmVuZCkKCg=="
    __queue = []

    @staticmethod
    def has_in_queue(name):
        for queued in Manager.__queue:
            if queued.get('name') == name:
                return True
        return False

    @staticmethod
    def add_to_queue(lib, create_item):
        # get name
        name = lib.get('name')
        if not name:
            url = lib.get('source')
            if url:
                name = Manager.getNameFromUrl(url)
        # name bad
        if not name:
            log('Error: Name not specified!', var=lib)
            return False
        # name ok
        if not Manager.has_in_queue(name):
            log('Adding \'' + name + '\' to queue...', level=2)

            item = create_item(name, lib)
            if item:
                item['name'] = name
                Manager.__queue.append(item)
                return True
        return False

    @staticmethod
    def init():
        ensureDirExists('./lib')
        Manager.config = loadYaml('project.yaml')

    @staticmethod
    def getItemFromUrl(url):
        urls = [
            '^([^/:]+\/[^/:]+).git$',
            '^([^/:]+\/[^/:]+)$',
            '^.+[/:]([^/]+\/[^/]+).git$',
            '^.+[/:]([^/]+\/[^/]+)$'
        ]
        item = { 'name': url }
        for regex in urls:
            m = re.search(regex, url)
            if m:
                item = { 'source': url, 'name': m.group(1) }
                break
        if args.name:
            item['name'] = args.name
        if args.source_host:
            item['source'] = args.source_host
        if item.get('name') == item.get('source'):
            del item['source']
        log('required url: ', var=url, level=2)
        log('item: ', var=item, level=2)
        return item

    @staticmethod
    def getIndexOf(item):
        for index, required in enumerate(Manager.config.get('require')):
            name1 = required.get('name')
            name2 = item.get('name')
            log('name1: ', var=name1, level=2)
            log('name2: ', var=name2, level=2)
            if name1 == name2:
                source = Manager.config.get('default', {}).get('source')
                source1 = item.get('source') or source
                source2 = required.get('source') or source
                log('source1: ', var=source1, level=2)
                log('source2: ', var=source2, level=2)
                if source1 == source2: return index
                if source1 == source2 + '/': return index
                if source1 == source2 + '/' + name2: return index
                if source1 + '/' == source2: return index
                if source1 + '/' + name1 == source2: return index
                if source1 + '/' + name1 == source2 + '/' + name2: return index
        return -1

    @staticmethod
    def require(url):
        item = Manager.getItemFromUrl(url)
        if Manager.getIndexOf(item) >= 0:
            log(item.get('name') + ' -> ' + url + ' already required!')
            return False
        Manager.config.get('require').append(item)
        with open('project.yaml', 'w') as project_file:
            yaml.dump(Manager.config, project_file, default_flow_style=False)
        return True

    @staticmethod
    def remove(url):
        item = Manager.getItemFromUrl(url)
        index = Manager.getIndexOf(item)
        if index >= 0:
            del Manager.config.get('require')[index]
            with open('project.yaml', 'w') as project_file:
                yaml.dump(Manager.config, project_file, default_flow_style=False)
            return True
        log('not found in required: ', var=url)
        return False

    @staticmethod
    def create_update_item(name, lib):
        path = 'lib/' + name + '/'
        package_file = path + 'package.yaml'
        if os.path.isfile(package_file):
            package_config = loadYaml(package_file)
            if 'require' in package_config:
                for required in package_config.get('require'):
                    Manager.add_to_queue(required, Manager.create_update_item)
        return lib

    @staticmethod
    def create_dump_item(name, lib):
        path = 'lib/' + name + '/'
        package_file = path + 'package.yaml'
        if not os.path.isfile(package_file):
            log('Error: \'' + package_file + '\' not present.')
            return False

        package_config = loadYaml(package_file)
        item = { 'entry': { 'type': 'file', 'path': 'init.lua' } }

        if 'require' in package_config:
            for required in package_config.get('require'):
                Manager.add_to_queue(required, Manager.create_dump_item)

        if 'entry' in package_config:
            item['entry'] = package_config.get('entry')

        entry_path = str(item.get('entry', {}).get('path', 'init.lua'))
        if entry_path:
            path = 'lib/'
            if item.get('entry').get('relative', True):
                path = path + name + '/'
            path = path + entry_path
            if not os.path.isfile(path):
                log('Error: \'' + path + '\' not present.')
                return None
            item['entry']['path'] = re.sub('\.?(init)?\.?$', '', path[:-4].replace('.', '`.').replace('/', '.'))
        return item

    @staticmethod
    def update():
        if not shutil.which('git'):
            print('Git not detected!')
        else:
            for required in Manager.config.get('require', {}):
                Manager.add_to_queue(required, Manager.create_update_item)
            for required in Manager.__queue:
                name = str(required.get('name'))
                source = required.get('source')
                if not source:
                    source = Manager.config.get('default', {}).get('source') + '/' + name
                log('name: ' + name + ', source: ' + source + ', skip...', 2)
                if not source:
                    log('Error: source not specified.')
                    continue
                source = str(source)
                log('Checking dependencies...', 2)
                
                if source == 'local':
                    log('Local folder. Skip git clone...', 2)
                    continue

                Manager.currentPath = './lib/' + name
                log('Cloning \'' + name + '\' (' + source + ') -> ' + Manager.currentPath)
                if os.path.exists(Manager.currentPath):
                    log('Directory already exists, pull changes...')
                    os.system('cd ' + Manager.currentPath + '; git pull')
                else:
                    os.system('git clone ' + source + ' ' + Manager.currentPath)

    @staticmethod
    def dump():
        for required in Manager.config.get('require', {}):
            Manager.add_to_queue(required, Manager.create_dump_item)
        log('Generating autoload file: ./lib/autoload.lua')
        log('Overwriting file: ./lib/autoload.lua', level=2)
        with open('lib/autoload.lua', 'w') as autoload:
            autoload.truncate()
            autoload.write("-- This file was generated by " + progname + " :)")
            autoload.write(str(base64.b64decode(Manager.autoload_template), 'utf-8'))
            for queued in Manager.__queue:
                type = queued.get('entry', {}).get('type')
                path = queued.get('entry', {}).get('path')
                if type == 'file':
                    autoload.write('require\'' + path + '\'\n')
                elif type == 'global':
                    name = queued.get('entry', {}).get('name')
                    autoload.write(name + ' = require\'' + path + '\'\n')
        log('File: ./lib/autoload.lua written successfully.', level=2)
        print('All done.\n\nYou can now use generated file with \'require"lib.autoload"\'.')

Manager.init()

# add repo to required
if args.command == 'require':
    Manager.require(args.source)

# remove repo from required
if args.command == 'remove':
    Manager.remove(args.source)

# update repos, clone from sources
if args.command == 'update':
    Manager.update()

# build queue and generate autoload
if args.command == 'dump':
    Manager.dump()
